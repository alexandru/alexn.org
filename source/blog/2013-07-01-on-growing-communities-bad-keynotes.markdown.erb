---
title: "On Growing Languages and Bad Keynotes"
archive: true
tags:
  - Scala
  - Community
  - Java
---

A coworker of mine came the other day with some weird ideas he got by
watching
[Rod Johnson's keynote](http://parleys.com/play/51c1ffe7e4b0d38b54f46231/chapter69/about)
from ScalaDays 2013. 

So I went ahead and watched it myself. I found his presentation
educational, but mean-spirited, so this is me arguing against some of
the points made.

<!-- read more -->

### "*Java endures, in reality it's not going away any time soon*"

That's not saying much, as the same can be said about Windows on
desktops. Fact of the matter is, this is missing the forest from the
trees - monoliths are never beaten at their own game. What usually
happens is that older technologies are disrupted by newer technologies
that make the popularity of the incumbents irrelevant, phenomena
described in a wonderful book called
[Innovator's Dilemma](http://www.amazon.com/The-Innovators-Dilemma-Revolutionary-Business/dp/0062060244).

Also, open technologies never really die, instead they usually adapt
and evolve. Only proprietary technologies die and if Oracle had its
way, Java would be proprietary, unfortunately for them that genie is
out of the bottle and I can't tell you how happy I am that Google won
that lawsuit.

### "*Scala's niche: leading enterprise language ... startups less likely to use Scala / still hate the JVM / still love dynamic languages*"

Again, this is missing the point. Most people don't really love
programming languages, they simply hate everything else. Pick any
developer and if he can't name at least 3 things that he hates with a
passion about his current programming language, it either means he's
still in honeymoon or it means that he simply does not care.

The programming languages that succeeded in startups did so based on
how quickly their ecosystem of libraries and tools map to the problem
domain - most startups don't choose Ruby, but rather Ruby on
Rails. They don't choose Python, but rather Django/Numpy/Scipy/Nltk.

The fact of the matter is that the enterprise is conservative, as the
enterprise is more likely to treat people as replaceable assets. Which
is why, except for the finance industry which pays obscene salaries,
the enterprise prefers mainstream languages for which they've got an
easier time to find replaceable and cheap developers.

To make inroads, the direct competition for new languages is not Java,
but rather Ruby/Python/Perl/PHP/Javascript which have also seen
massive uptake in the enterprise - the technologies used by startups
today or by people in their personal projects are going to be used in
the enterprise tomorrow. Not catering to startups and personal
projects means death for new technologies, unless you can afford to
buy a lot of lap-dances for managers.

### "*Java's success was partly due to being less powerful than C++*"

This is one of those myths that keeps coming up again and again. 

Fact of the matter is, Java's success was never to the expense of
C++. Linus Torvalds is known to have said in one of his rants that
using a programming language without a garbage collector makes no
sense for most apps. And C++ wasn't the only language around - Perl,
Smalltalk, Visual Basic - the world had plenty to pick from.

The pie also got a lot bigger since 1996, when JDK 1.0 was
released. C++ itself experienced a lot of growth since then and is
more popular than ever. In fact I would be willing to bet that C++ is
still more popular than Java, but that's another discussion.

It is worth to consider why Java makes the lives of developers better,
when compared to C++, so here are some highlights of Java:

* memory safety
* garbage collector
* guarantees about the memory model (JSR 133)
* exception stack traces instead of segmentation faults with core dumps
* multi-threading primitives baked in
* batteries included in a real standard library
* only one compiler
* saner OOP
* compile once, run everywhere
* no C legacy either in the language or in the libraries

If anything, Java is better because it doesn't have the same memory
management issues, with garbage collectors being the biggest
improvement for developers in the history of our industry. But this
also makes Java unusable for projects that need manual memory
management, either for efficiency reasons or because the system needs
real-time characteristics.

Basically if a language doesn't suffer from memory-management issues,
then direct analogies with C++ do not make any sense.

C++ is also a mess from all points of view. Future historians will be
able to assess the maturity of C++ software projects based on the
number of different String implementations it uses or by the number of
guards in place to protect against buffer overflows.

Of course, some people will always say that C++ lost to Java due to
operator overloading, or other such nonsense, but that's just bullshit
and I invite them to watch
[Growing a Language, by Guy Steele](http://www.youtube.com/watch?v=_ahvzDzKdB0).

### "*Front-end no longer on the JVM, predominantly Javascript*"

This is Java's failure to properly integrate with native GUI toolkits
and Javascript is just the next frontier that Java will fail to
address. 

Few people are happy when depeloping in Javascript, which is why
we've got light languages that map well to its type system, like
CoffeeScript or TypeScript, we have more ambitious compilers like
[Google Web Toolkit](https://developers.google.com/web-toolkit/),
[WebSharper](http://www.websharper.com/home) or
[ClojureScript](https://github.com/clojure/clojurescript) and we even
have replacements, such as [Dart](http://dartlang.org/) and
[PNaCl](http://www.chromium.org/nativeclient/pnacl).

The latest version of Firefox has optimizations for
[asm.js](http://asmjs.org/), a subset of Javascript that's meant for
being targeted by compilers, like
[Emscripten](https://github.com/kripken/emscripten), a
LLVM-to-Javascript compiler. This means we can now compile and run the
[Unreal Engine](http://www.unrealengine.com/html5/) in the browser
with reasonable performance and nice visuals.

Because of these developments, coupled with Source Maps, Javascript is
increasingly becoming a compilation target. There's even an exciting
new project for compiling Scala to Javascript:
[lampepfl/scala-js](https://github.com/lampepfl/scala-js)

Here's a more accurate prediction - languages that will not compile
for running in the browser will be marginalized and stagnate.

### "*Java is simpler/more readable than Scala*"

The reason for all the Java (the language) hatred has to do with Java
being a statically typed language in which the type system doesn't
help you, at all. It's one of the dumbest type systems in
existence. With dynamic languages at least the type system doesn't
stay in your way.

Many developers also tend to shy away from over-engineered solutions -
JPA sucks for example and personally I'm better off with a light
wrapper around JDBC. Dependency injection itself is a symptom of a
bigger problem (Python developers never talk about dependency
injection). And I still don't know what's a *transaction manager* and
why I need one - never cared to find out and have been quite happy
thus far ;-)

Have you ever watched developers struggle with generics and wildcards
in Java? Have you ever used libraries that rely on bytecode generation
to do their thing, with incomprehensible internals and god-awful error
traces? Have you ever had to deal with factories of factories? Have
you ever had to reason about the memory model when doing
multi-threading? Have you ever been bitten by the usage of `==`?

Java's simplicity is missleading and I invite people to watch
[Simple Made Easy, by Rich Hickey](http://www.infoq.com/presentations/Simple-Made-Easy).

### "*All leading languages are similar to Java*"

Let's see how Ruby is different:

* dynamic typing
* pure OOP, driven by message-passing, mutable classes,
  meta-programming and prototypes when you need them, in true Smalltalk
  fashion  
* multiple thriving implementations, including [JRuby](http://jruby.org/), [Rubinius](http://rubini.us/) and [MacRuby](http://macruby.org/)
* suitable for poetry 
* [ISO standard](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=59579)

[JRuby](http://jruby.org/), the JVM implementation, is mainly used by
Ruby developers and not Java developers, as JRuby is part of Ruby's
ecosystem and not Java's ecosystem. As we speak, all important
libraries, including Rails, run well on top of JRuby and JRuby is the
most popular alternative language running on top of the JVM.

### "*Scala needs to be more boring - does anyone really stick with Java because Scala doesn't have enough features?*"

Such opinions are nothing more than straw-man arguments. I personally
know a couple of really good Java developers. Scala sparkles their
interest precisely because it is different, with the biggest argument
against it being that - it still feels like a marginal improvement
over Java.

And I'm not talking about Blub programmers here, I'm talking about
good developers that know their stuff and understand what Scala is
about, with the consensus being that they'd rather use
[Guava](http://code.google.com/p/guava-libraries/) and wait for Java
8.

Making Scala be more like Java is a waist of resources, as the people
that dislike Java so much already moved on, while the others are more
prone to wait for newer Java versions, unless you give them something
to make their jaw drop ;-)

### "*[people] need to stop reinventing wheels*"

But that's precisely what kept Java so attractive. How many Java web
frameworks are there? How many libraries for dependency injection?

If you want to look at a community that's a mono-culture who doesn't
reinvent wheels, look no further than .NET and compare. As a matter of
fact, the first wheel wasn't round and thank God for whomever
reinvented the horse.

## Final Thoughts

It was a poor keynote.

Note for the wise: it's always a bad idea to insult people, even if
the intentions are good.

Other thoughts by other people:

* [How the Scala Days 2013 Keynote should have gone](http://alvinalexander.com/scala/scala-days-2013-keynote), by Alvin Alexander
* [Scala in 2007 - 2013](http://code.technically.us/post/54293186930/scala-in-2007-2013), by Nathan Hamblen
