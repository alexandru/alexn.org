---
title: "JavaScript's Promise is Memory Unsafe"
clean_summary:
  JavaScript's Promise is memory unsafe in recursive loops and what you can do about it.
tags:
  - Code
  - JavaScript
  - Promise
  - Funfix
  - Functional
---

This piece of code will crash your Node.js process or browser:

```typescript
function signal(i) {
  return new Promise(cb => setImmediate(() => cb(i)))
}

function loop(n) {
  return signal(n).then(i => {
    if (i % 1000 == 0) console.log(i)
    return loop(n + 1)
  })
}

loop(0).catch(console.error)
```

This is equivalent with this `async` function:

```typescript
async function loop(n) {
  const i = await signal(n)
  if (i % 1000 == 0) console.log(i)

  // Recursive call
  return await loop(n + 1)
}
```

Of course, if this loop would be synchronous, not using `Promise` or `async` / `await`,
then the process would blow up with a stack overflow error because
at the moment of writing JavaScript does not do 
[tail calls optimizations](https://en.wikipedia.org/wiki/Tail_call)
(until everybody implements ECMAScript 6 fully at least).

But before you jump to conclusions, this has NOTHING to do with JavaScript's
lack of TCO support. This is because in our recursive function it's
not JavaScript's [call stack](https://en.wikipedia.org/wiki/Call_stack) 
that's managing that loop, but rather the `Promise` implementation. 
That recursive call is asynchronous and so it does not abuse the call stack
by definition.

Unfortunately, just like a regular function using the call stack for those 
recursive calls, the `Promise` implementation is abusing the heap memory,
not chaining `then` calls correctly. And that sample should not leak, 
the `Promise` implementation should be able to do the equivalent of TCO 
and in such a case eliminate frames in the `then` chain being created.

## Functional Programming You Say?

The solution, if you insist on using JavaScript's `Promise`, is to work 
with non-recursive functions:

```typescript
async function loop(n) {
  let i = 0

  while (true) {
    i = await signal(i + 1)
    if (i % 1000 == 0) console.log(i)
  }
}
```

But at this point any semblance of functional programming, if you ever had
any, goes out the window.

## Funfix

<a href="https://funfix.org">
  <%= image_tag "funfix-1024.png", :class => "right", :width => "200" %>
</a>

As a shameless plug I've been working on [Funfix](https://funfix.org/),
a JavaScript library for functional programming (capital FP), supporting 
[TypeScript](https://www.typescriptlang.org/) and [Flow](https://flow.org/)
types out of the box.

Funfix exposes [Future&lt;A&gt;](https://funfix.org/api/exec/classes/future.html), an
eager `Promise` alternative that's safe, cancellable and filled with goodies,
along with [IO&lt;A&gt;](https://funfix.org/api/effect/classes/io.html), a lazy, lawful,
cancellable data type for handling all kinds of side effects, inspired by Haskell,
the two being complementary.

This piece of code powered by `Future` does not leak:

```typescript
import { Future } from "funfix"

function loop(n) {
  return Future.of(() => n).flatMap(i => {
    if (i % 1000 == 0) console.log(i)
    return loop(n + 1)
  })
}

loop(0).recover(console.error)
```

And neither does this one, powered by `IO`:

```typescript
import { IO } from "funfix"

function loop(n) {
  return IO.of(() => n).flatMap(i => {
    if (i % 1000 == 0) console.log(i)
    return loop(n + 1)
  })
}

loop(0).run().recover(console.error)
```

This `IO` is a port of [Monix](https://monix.io/)'s 
[Task](https://monix.io/docs/2x/eval/task.html), being a better
`IO` than Haskell's `IO` due to its cancellable nature ;-)

In [PR #57](https://github.com/funfix/funfix/pull/57) I've also
fixed the memory leak for `Future`, doing the same tricks that 
Scala's [Future](http://www.scala-lang.org/api/2.12.3/scala/concurrent/Future.html)
is doing.

And note that this is harder to do for Funfix's `Future` due to also
having to deal with chains of `Cancelable` references, which can
also leak.

## Final Words

That the current JavaScript `Promise` implementation has this leak
is a big problem, because tail-recursive calls are the cornerstone
of functional programming.

Yes, it's true that `Promise` is not a useful monadic type for doing FP,
since it does not suspend side effects (which is why you should 
use [IO](https://funfix.org/api/effect/classes/io.html)), but that's 
beside the point.

This is also why I fear standardization by committee in general. Along with 
the totally awkward `then` signature that can't be safely described with 
TypeScript's or Flow's types, this is another example of how standard 
solutions can do harm.

I was once asked about whether JavaScript should also have a standard 
`Option` (`Maybe`) data type. I said no, because if it ever happens,
it will probably be broken.
